/**카운트 다운
 * 알고리즘 : DP
 * 핵심 아이디어:
 * 1. target이 10만임으로 아예 DP로 풀어도 문제가 없다. 추가로 역탐색은 어자피 다트 1개를 더 던질 수 있는지만 보면 되기 때문에 10만 * 60으로 600만, 시간은 충분하다.
 * 2. 1 ~ 60에서 다트 던질 수 있는 경우 체크, 싱글/불일 경우 1, 아닌 경우 2, 불가능한 경우 0
 * 3. DP로 역으로 60개 내려가면서 다트 1회 더 추가해서 갱신될 수 있는 경우 있는지 탐색
 * 4. 이 과정에서 아예 처음이거나, 다트 총 던진 횟수가 갱신되거나, 다트 총 던진 횟수는 같아도 싱글/불 맞춘 갯수가 갱신되거나 <= 이렇게 3경우에 DP 갱신
 * 헤멘 부분 :
 * 1. 예전에 풀었을 때는 접근 자체를 잘못함 (DP로 안품)
 * 2. 다시 풀 때는 "다트 총 던진 횟수는 같아도 싱글/불 맞춘 갯수가 갱신되거나" => 이 부분에서 싱글/불 갯수를 <= 으로 비교 안하고 ==으로 비교해서 틀림..
 * */
class 카운트_다운 {
    public int[] solution(int target) {
        int[] able = new int[61];
        int[][] dp = new int[target+1][2];
        for (int i = 1; i <= 20; i++) {
            able[i] = 1; // 싱글
            able[i*2] = 2; // 더블
            able[i*3] = 2; // 트리플
        }
        able[50] = 1; // 불

        // i 가 타켓 위치
        for (int i = 1; i <= target; i++) {
            if (i <= 60 && able[i] != 0){
                dp[i][0] = 1;
                dp[i][1] = able[i] == 1? 1 : 0;
                continue;
            }

            // j 가 탐색 위치
            for (int j = i-1; j >= 1 && i-j <= 60; j--) {
                // 기존 DP에서 1번의 추가 점수로 도달할 수 있을 때
                if (able[i-j] != 0){
                    // 처음 가능한 경우이거나, 탐색 DP에서 1번 더 던진 횟수가 현재 총 던진 횟수보다 적거나, 총 횟수는 같지만 싱글/불 갯수가 더 많을 때
                    if (dp[i][0] == 0 || dp[i][0] > dp[j][0] + 1
                            || (dp[i][0] == dp[j][0] + 1 && dp[i][1] <= dp[j][1])) {
                        dp[i][0] = dp[j][0] + 1;
                        dp[i][1] = dp[j][1] + (able[i-j] == 1? 1 : 0);
                    }
                }
            }
        }

        return dp[target];
    }
}
